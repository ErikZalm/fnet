/*
 *    CF_Startup.c - Default init/startup/termination routines for
 *                     Embedded Metrowerks C++
 *
 *    Copyright © 1993-1998 Metrowerks, Inc. All Rights Reserved.
 *    Copyright © 2005 Freescale semiConductor Inc. All Rights Reserved.
 *
 *
 *    THEORY OF OPERATION
 *
 *    This version of thestartup code is intended for linker relocated
 *    executables.  The startup code will assign the stack pointer to
 *    __SP_INIT, assign the address of the data relative base address
 *    to a5, initialize the .bss/.sbss sections to zero, call any
 *    static C++ initializers and then call main.  Upon returning from
 *    main it will call C++ destructors and call exit to terminate.
 */


#include "fnet.h"

#include "startcf.h"

/* copy ROM to RAM locations.  Set to 0 for more aggressive dead stripping ... */
#ifndef SUPPORT_ROM_TO_RAM
#define SUPPORT_ROM_TO_RAM			1
#endif

	/* imported data */

extern unsigned long _SP_INIT, _SDA_BASE;
extern unsigned long _START_BSS, _END_BSS;
extern unsigned long _START_SBSS, _END_SBSS;
extern unsigned long __DATA_RAM, __DATA_ROM, __DATA_END;

	/* imported routines */

extern int main(int, char **);
extern void exit(int);

	/* exported routines */

extern void _startup(void);


void clear_mem(char *dst, unsigned long n);



#if FNET_CFG_COMP_CW /* Used by CW startup code. */

/*
 *	Routine to copy a single section from ROM to RAM ...
 */
void __copy_rom_section(char* dst, const char* src, unsigned long size)
{
    #if 0
    	if (dst != src)
		 while (size--)
		    *dst++ = *src++;
    #else
        fnet_memcpy(dst, src, size);
    #endif        		    
}

/*
 *	Routine that copies all sections the user marked as ROM into
 *	their target RAM addresses ...
 *
 *	__S_romp is automatically generated by the linker if it
 *	is referenced by the program.  It is a table of RomInfo
 *	structures.  The final entry in the table has all-zero
 *	fields.
 */
void __copy_rom_sections_to_ram(void)
{
	RomInfo		*info;

	/*
	 *	Go through the entire table, copying sections from ROM to RAM.
	 */
	for (info = _S_romp; info->Source != 0L || info->Target != 0L || info->Size != 0; ++info)
        __copy_rom_section( (char *)info->Target,(char *)info->Source, info->Size);
							
}

/*
 *    Routine to clear out blocks of memory should give good
 *    performance regardless of 68k or ColdFire part.
 */
void clear_mem(char *dst, unsigned long n)
{
    #if 0
    	unsigned long i;
    	long *lptr;

    	if (n >= 32)
    	{
    		/* align start address to a 4 byte boundary */
    		i = (- (unsigned long) dst) & 3;

    		if (i)
    		{
    			n -= i;
    			do
    				*dst++ = 0;
    			while (--i);
    		}

    		/* use an unrolled loop to zero out 32byte blocks */
    		i = n >> 5;
    		if (i)
    		{
    			lptr = (long *)dst;
    			dst += i * 32;
    			do
    			{
    				*lptr++ = 0;
    				*lptr++ = 0;
    				*lptr++ = 0;
    				*lptr++ = 0;
    				*lptr++ = 0;
    				*lptr++ = 0;
    				*lptr++ = 0;
    				*lptr++ = 0;
    			}
    			while (--i);
    		}
    		i = (n & 31) >> 2;

    		/* handle any 4 byte blocks left */
    		if (i)
    		{
    			lptr = (long *)dst;
    			dst += i * 4;
    			do
    				*lptr++ = 0;
    			while (--i);
    		}
    		n &= 3;
    	}

    	/* handle any byte blocks left */
    	if (n)
    		do
    			*dst++ = 0;
    		while (--n);
    #else

        fnet_memset_zero(dst, n);
        
    #endif		
}

#endif


